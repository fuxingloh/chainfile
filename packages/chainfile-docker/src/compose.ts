import { randomBytes } from 'node:crypto';

import { Chainfile, Container, ParamOptions, ParamReference, validate } from '@chainfile/schema';
import yaml from 'js-yaml';

import { version } from '../package.json';

/**
 * Synthesize a Chainfile into `docker.*.yml` & `.env` files.
 */
export class Compose {
  public readonly chainfile: Chainfile;
  public readonly params: Record<string, string>;
  public readonly suffix: string;

  /**
   * @param chainfile definition to synthesize.
   * @param params to override in the chainfile
   * @param suffix for the container names to prevent conflicts.
   */
  constructor(chainfile: object, params: Record<string, string>, suffix: string = randomBytes(4).toString('hex')) {
    validate(chainfile);
    this.chainfile = chainfile as Chainfile;
    this.suffix = suffix;
    this.params = new ComposeParams(this.chainfile).init(params);
  }

  public synthDotEnv(): string {
    return Object.entries({
      // TODO(?): this.params should filter out values that are not used in the compose file
      ...this.params,
      CHAINFILE_PARAMS: JSON.stringify(this.params),
    })
      .map(([key, value]) => `${key}=${value}`)
      .join('\n');
  }

  public synthCompose(): string {
    return (
      [
        `# Generated by @chainfile/docker:${version}, do not edit manually.`,
        `# Version: ${version}`,
        `# Chainfile Name: ${this.chainfile.name}`,
        `# Chainfile CAIP-2: ${this.chainfile.caip2}`,
        '',
        yaml.dump(
          {
            name: this.chainfile.name.toLowerCase().replaceAll(/[^a-z0-9_-]/g, '_'),
            services: {
              ...this.newAgent(),
              ...this.newServices(),
            },
            networks: {
              chainfile: {},
            },
            volumes: this.newVolumes(),
          },
          {
            lineWidth: 120,
          },
        ),
      ]
        .join('\n')
        // Replace all $ with $$$ to escape them in the compose file
        .replaceAll('$', '$$$')
        .replaceAll('$$$${CHAINFILE_PARAMS}$$$$', '${CHAINFILE_PARAMS}')
        // Unescape $$$${value}$$$$ to ${value}
        .replaceAll(/\$\$\$\$\{([a-z]+(_[a-z0-9]+)*)}\$\$\$\$/g, (_, key) => {
          return `$\{${key}}`;
        })
    );
  }

  private newVolumes(): Record<string, object> {
    return Object.fromEntries(
      Object.entries(this.chainfile.volumes ?? {}).map(([name]) => {
        // Volume.type are currently ignored.
        return [name, {}];
      }),
    );
  }

  private newAgent(): Record<'agent', object> {
    return {
      agent: {
        container_name: `agent-${this.suffix}`,
        image: `ghcr.io/vetumorg/chainfile-agent:${version}`,
        ports: ['0:1569'],
        environment: {
          // Docker compose automatically evaluate environment literals here
          CHAINFILE_JSON: JSON.stringify(this.chainfile),
          CHAINFILE_PARAMS: '$${CHAINFILE_PARAMS}$$',
          DEBUG: process.env.DEBUG ?? 'false',
        },
        volumes: [],
        networks: {
          chainfile: {},
        },
      },
    };
  }

  private newServices(): Record<string, object> {
    // TODO: resources (cpu, memory) is not supported for this runtime:
    //  https://docs.docker.com/compose/compose-file/compose-file-v3/#resources
    //  I'm not sure if we should since docker-compose typically runs on a single machine
    //  and utilizes the host's resources.
    //  Which limits its usefulness in orchestration when placement is not a concern.
    //  Adding them would make the compose hard limit the resources of the host even if the host
    //  has more resources available.

    function createPorts(container: Container): string[] {
      return Object.values(container.endpoints ?? {}).map((endpoint) => {
        // TODO: Support Binding P2P Port Statically
        return `0:${endpoint.port}`;
      });
    }

    function createVolumes(container: Container): object[] {
      return (container.mounts ?? []).map((mount) => {
        return {
          type: 'volume',
          source: mount.volume,
          target: mount.mountPath,
          volume: {
            subpath: mount.subPath,
          },
        };
      });
    }

    return Object.fromEntries(
      Object.entries(this.chainfile.containers).map(([name, container]) => {
        return [
          name,
          {
            container_name: `${name}-${this.suffix}`,
            image: container.image + ':' + this.getParam(container.tag),
            command: container.command,
            environment: Object.fromEntries(
              Object.entries(container.environment ?? {}).map(([key, valueOrReference]) => {
                return [key, this.getParam(valueOrReference)];
              }),
            ),
            ports: createPorts(container),
            volumes: createVolumes(container),
            networks: {
              chainfile: {},
            },
          },
        ];
      }),
    );
  }

  private getParam(param: string | ParamReference): string {
    if (typeof param === 'string') {
      return param;
    }
    return `$$\{${param.$param}}$$`;
  }
}

export class ComposeParams {
  constructor(protected readonly chainfile: Chainfile) {}

  /**
   * @param override params in the chainfile
   */
  public init(override: Record<string, string> = {}): Record<string, string> {
    if (this.chainfile.params === undefined) {
      return {};
    }

    const params = Object.fromEntries(
      Object.entries(this.chainfile.params).map(([name, param]) => {
        if (override[name] !== undefined) {
          return [name, override[name]];
        }

        if (typeof param === 'string') {
          return [name, param];
        }

        if (param.default !== undefined) {
          return this.default(name, param.default);
        }

        throw new Error(`Unsupported param: ${JSON.stringify(param)}`);
      }),
    );

    return this.interpolate(params);
  }

  protected default(name: string, options: NonNullable<ParamOptions['default']>): [string, string] {
    if (typeof options === 'string') {
      return [name, options];
    }

    if (options.random !== undefined) {
      return [name, randomBytes(options.random.bytes).toString(options.random.encoding)];
    }

    throw new Error(`Default options not supported: ${JSON.stringify(options)}`);
  }

  protected interpolate(params: Record<string, string>): Record<string, string> {
    let updated: boolean;
    do {
      updated = false;
      for (const [name, value] of Object.entries(params)) {
        params[name] = value.replace(/\$\{([a-z]+(_[a-z0-9]+)*)}/g, (_, key) => {
          updated = true;
          return params[key];
        });
      }
    } while (updated);
    return params;
  }
}
