import { randomBytes } from 'node:crypto';

import expand from 'dotenv-expand';
import yaml from 'js-yaml';
import { Container, KarfiaDefinition } from 'karfia-definition';
import { validate } from 'karfia-definition/schema';

import { version } from './package.json';

/**
 * Synthesize a KarfiaDefinition into `docker.*.yml` & `.env` files.
 */
export class Synthesizer {
  private readonly definition: KarfiaDefinition;
  /**
   * A random deploymentId is generated for each synthesizer to uniquely the lifetime of a deployment.
   */
  public readonly deploymentId: string = randomBytes(8).toString('hex');

  constructor(definition: KarfiaDefinition | any) {
    validate(definition);
    this.definition = definition;
  }

  public synthEnv(): string {
    const env = expand({
      parsed: {
        KARFIA_DEPLOYMENT_ID: this.deploymentId,
        ...Object.entries(this.definition.environment ?? {}).reduce(
          (env, [key, factory]) => {
            if (factory.type === 'RandomBytes') {
              env[key] = randomBytes(factory.length).toString(factory.encoding);
              return env;
            }
            if (factory.type === 'Expansion') {
              env[key] = factory.value;
              return env;
            }

            // if (factory.type === 'Injection') {
            // TODO: Prompt if CLI, inject if constructs.
            //  To allow for simple configuration, e.g. Masternode Keys.

            // @ts-expect-error so that we error if we forget to handle a new factory type
            throw new Error(`Unsupported Environment Factory: ${factory.type}`);
          },
          {} as Record<string, string>,
        ),
      },
    }).parsed;

    return Object.entries(env ?? {})
      .map(([key, value]) => `${key}=${value}`)
      .join('\n');
  }

  public synthCompose(): string {
    return [
      `# Generated by karfia-docker-compose, do not edit manually.`,
      `# Karfia Version: ${version}`,
      `# Definition ID: ${this.definition.id}`,
      `# Definition Name: ${this.definition.name}`,
      `# Definition CAIP-2: ${this.definition.caip2}`,
      '',
      yaml.dump(
        {
          name: this.definition.id.replaceAll(/[^a-z0-9_-]/g, '_'),
          services: {
            ...this.createKarfiaAgent(),
            ...this.createContainers(),
          },
          networks: {
            karfia: {},
          },
          volumes: {
            karfia: {},
          },
        },
        {
          lineWidth: 120,
        },
      ),
    ].join('\n');
  }

  private createKarfiaAgent(): Record<'karfia-agent', object> {
    const definitionJson = JSON.stringify({
      ...this.definition,
      $schema: undefined,
    }).replaceAll('$', '$$$');

    const EnvironmentMapping = Object.keys(this.definition.environment ?? {}).reduce(
      (env, key) => {
        env[`KARFIA_ENVIRONMENT_${key}`] = `$\{${key}}`;
        return env;
      },
      {} as Record<string, string>,
    );

    return {
      'karfia-agent': {
        container_name: 'karfia-agent-${KARFIA_DEPLOYMENT_ID}',
        image: `ghcr.io/fuxingloh/karfia-agent:${version}`,
        ports: ['0:1194'],
        environment: {
          // Docker compose automatically evaluate environment literals here
          KARFIA_DEFINITION_JSON: definitionJson,
          KARFIA_DEPLOYMENT_ID: '${KARFIA_DEPLOYMENT_ID}',
          ...EnvironmentMapping,
        },
        volumes: [
          {
            type: 'volume',
            source: 'karfia',
            target: '/var/karfia',
          },
        ],
        networks: {
          karfia: {},
        },
      },
    };
  }

  private createContainers(): Record<string, object> {
    // TODO: resources (cpu, memory) is not supported yet for docker-compose
    //  https://docs.docker.com/compose/compose-file/compose-file-v3/#resources
    //  I'm not sure if we should since docker-compose typically runs on a single machine
    //  and utilizes the host's resources.
    //  Which limits its usefulness in orchestration when placement is not a concern.
    //  Adding them would make the compose hard limit the resources of the host even if the host
    //  has more resources available.

    function createPorts(container: Container): string[] {
      return Object.values(container.endpoints).map((endpoint) => {
        // TODO: Support Binding P2P Port Statically
        return `0:${endpoint.port}`;
      });
    }

    interface Volume {
      type: 'volume';
      source?: string;
      target: string;
    }

    function createVolumes(container: Container): Volume[] {
      const volumes: Volume[] = [
        {
          type: 'volume',
          source: 'karfia',
          target: '/var/karfia',
        },
      ];

      container.volumes?.persistent?.paths.forEach((path) => {
        volumes.push({
          type: 'volume',
          target: path,
        });
      });

      container.volumes?.ephemeral?.paths.forEach((path) => {
        volumes.push({
          type: 'volume',
          target: path,
        });
      });

      return volumes;
    }

    return Object.entries(this.definition.containers).reduce(
      (services, [name, container]) => {
        services[name] = {
          container_name: `${name}-$\{KARFIA_DEPLOYMENT_ID}`,
          image: container.image,
          command: container.command,
          environment: Object.entries(container.environment ?? {}).reduce(
            (env, [key, value]) => {
              return {
                ...env,
                [key]: typeof value === 'string' ? value : `$\{${value.key}}`,
              };
            },
            {} as Record<string, string>,
          ),
          ports: createPorts(container),
          volumes: createVolumes(container),
          networks: {
            karfia: {},
          },
        };
        return services;
      },
      {} as Record<string, object>,
    );
  }
}
